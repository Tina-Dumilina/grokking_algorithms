# Грокаем алгоритмы

## Бинарный поиск
**Бинарный поиск** – это алгоритм; на входе он получает отсортированный список элементов, который при каждой итерации разделяется пополам. Если элемент, который вы ищете, присутствует в списке, то бинарный поиск возвращает ту позицию, в которой он был найден. В противной случае бинарный поиск возвращает `null`.

[Бинарный поиск](https://github.com/Tina-Dumilina/grokking_algorithms/blob/main/binary_search.js)

## О-большое

Специальная нотация "О-большое" описывает скорость работы алгоритма.

- Скорость алгоритмов измеряется не в секундах, а в темпе роста количества операций.
- По сути формула описывает, насколько быстро возрастает время выполнения алгоритма с увеличением размера входных данных.

### Разновидности:

- *O(1)* – постоянное время. Пример: чтение значения элемента в массиве по его индексу.
- *O(log n)* – логарифмическое время. Пример: бинарный поиск.
- *O(n)* – линейное время. Пример: простой поиск.
- *O(n * log n)*. Пример: эффективные алгоритмы сортировки.
- *O(n2)*. Пример: медленные алгоритмы сортировки.
- *O(n!)*. Пример: задача о коммивояжере.

## Массивы и связанные списки
При использовании массивов его элементы размещаются в памяти последовательно. При добавлении нового элемента может возникнуть ситуация, когда следующая ячейка памяти занята и места не осталось, тогда массив придется переместить в другой отдел памяти, где он сможет поместиться полностью.

При использовании связанного списка элементы могут размещаться где угодно в памяти. В каждом элементе хранится адрес следующего элемента списка. 

### Чтение

Массивы подходят для чтения элементов в произвольных позициях, потому что обращение к любому элементу в массиве происходит мгновенно.

В связанном списке элементы не хранятся рядом друг с другом, поэтому мгновенно определить позицию i-го элемента в памят невозможно – нужно обратиться к первому элементу, чтобы получить адрес второго элемента и т.д.

### ИТОГ:

Связанные списки хорошо подходят для вставки/удаления, а массивы – для произвольного доступа к элементам.

|          | Массивы | Связанные списки |
|----------|---------|------------------|
| Чтение   |   O(1)  |       O(n)       |
| Вставка  |   O(n)  |       O(1)       |
| Удаление |   O(n)  |       O(1)       |

## Сортировка выбором

Идея метода состоит в том, чтобы создавать отсортированную последовательность путем присоединения к ней одного элемента за другим в правильном порядке. Например, отсортировать песни в плейлисте от большего количества прослушиваний к меньшему. Суть заключается в том, чтобы последовательно проходить по списку, найти песню с наибольшим количеством воспроизведений и добавить песню в новый список.

**Нотация**: *O(n2)*
<br>Во-первых, необходимо проверить каждый элемент в списке (*On*). Во-вторых, эту операцию необходимо выполнить *n* раз.

[Сортировка выбором](https://github.com/Tina-Dumilina/grokking_algorithms/blob/main/selection_sort.js)

## Быстрая сортировка

### Разделяй и властвуй

Решение задачи методом "разделяй и властвуй" состоит из двух шагов:

1. Сначала определяем базовый случай. Это должен быть простейший случай из всех возможных.
Базовым случаем массива часто оказывается пустой массив или массив из одного элемента.
2. Задача делится и сокращается до тех пор, пока не будет сведена к базовому случаю.

[Сумма всех чисел массива](https://github.com/Tina-Dumilina/grokking_algorithms/blob/main/sum.js) <br>
[Рекурсивная функция подсчета количества элементов в списке](https://github.com/Tina-Dumilina/grokking_algorithms/blob/main/recursive_array_length.js) <br>
[Рекурсивный поиск наибольшего числа в списке](https://github.com/Tina-Dumilina/grokking_algorithms/blob/main/recursive_find_biggest_number.js)

### Быстрая сортировка массива 

1. Сначала в массиве выбирается элемент, который называется *опорным*. Например, первый элемент массива.
2. Начинаем процесс разделения: находим элементы меньше опорного и больше опорного. 
<br>Массив `[15, 10, 44, 33]` разделяется на левый подмассив - `[15, 10]`, опорный элемент - 33, правый подмассив - `[44]`. Если бы подмассивы были отсортированы, то их можно было бы объединить в порядке "левый подмассив - опорный элемент - правый подмассив". 

Быстродействие быстрой сортировки сильно зависит от выбора опорного элемента. В худшем случае это *O(n2)*, в среднем случае - *O(n * log n)*.

[Быстрый поиск](https://github.com/Tina-Dumilina/grokking_algorithms/blob/main/quick_sort.js)

## Хеш-таблицы

### Хеш-функции
Хеш-функция представляет собой функцию, которая получает строку и возвращает число. Хеш-функция неизменно связывае  строку с одним индексом.

Хеш-таблица (ассоциативный массив / словарь) = хеш-функция + массив.
