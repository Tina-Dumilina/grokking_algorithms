# Грокаем алгоритмы

## Бинарный поиск
**Бинарный поиск** – это алгоритм; на входе он получает отсортированный список элементов, который при каждой итерации разделяется пополам. Если элемент, который вы ищете, присутствует в списке, то бинарный поиск возвращает ту позицию, в которой он был найден. В противной случае бинарный поиск возвращает `null`.

[Бинарный поиск](https://github.com/Tina-Dumilina/grokking_algorithms/blob/main/binary_search.js)

## О-большое

Специальная нотация "О-большое" описывает скорость работы алгоритма.

- Скорость алгоритмов измеряется не в секундах, а в темпе роста количества операций.
- По сути формула описывает, насколько быстро возрастает время выполнения алгоритма с увеличением размера входных данных.

### Разновидности:

- *O(1)* – постоянное время. Пример: чтение значения элемента в массиве по его индексу.
- *O(log n)* – логарифмическое время. Пример: бинарный поиск.
- *O(n)* – линейное время. Пример: простой поиск.
- *O(n * log n)*. Пример: эффективные алгоритмы сортировки.
- *O(n2)*. Пример: медленные алгоритмы сортировки.
- *O(n!)*. Пример: задача о коммивояжере.

## Массивы и связанные списки
При использовании массивов его элементы размещаются в памяти последовательно. При добавлении нового элемента может возникнуть ситуация, когда следующая ячейка памяти занята и места не осталось, тогда массив придется переместить в другой отдел памяти, где он сможет поместиться полностью.

При использовании связанного списка элементы могут размещаться где угодно в памяти. В каждом элементе хранится адрес следующего элемента списка. 

### Чтение

Массивы подходят для чтения элементов в произвольных позициях, потому что обращение к любому элементу в массиве происходит мгновенно.

В связанном списке элементы не хранятся рядом друг с другом, поэтому мгновенно определить позицию i-го элемента в памят невозможно – нужно обратиться к первому элементу, чтобы получить адрес второго элемента и т.д.

### ИТОГ:

Связанные списки хорошо подходят для вставки/удаления, а массивы – для произвольного доступа к элементам.

|          | Массивы | Связанные списки |
|----------|---------|------------------|
| Чтение   |   O(1)  |       O(n)       |
| Вставка  |   O(n)  |       O(1)       |
| Удаление |   O(n)  |       O(1)       |

## Сортировка выбором

Идея метода состоит в том, чтобы создавать отсортированную последовательность путем присоединения к ней одного элемента за другим в правильном порядке. Например, отсортировать песни в плейлисте от большего количества прослушиваний к меньшему. Суть заключается в том, чтобы последовательно проходить по списку, найти песню с наибольшим количеством воспроизведений и добавить песню в новый список.

**Нотация**: *O(n2)*
<br>Во-первых, необходимо проверить каждый элемент в списке (*On*). Во-вторых, эту операцию необходимо выполнить *n* раз.

[Сортировка выбором](https://github.com/Tina-Dumilina/grokking_algorithms/blob/main/selection_sort.js)

## Быстрая сортировка

### Разделяй и властвуй

Решение задачи методом "разделяй и властвуй" состоит из двух шагов:

1. Сначала определяем базовый случай. Это должен быть простейший случай из всех возможных.
Базовым случаем массива часто оказывается пустой массив или массив из одного элемента.
2. Задача делится и сокращается до тех пор, пока не будет сведена к базовому случаю.

[Сумма всех чисел массива](https://github.com/Tina-Dumilina/grokking_algorithms/blob/main/sum.js) <br>
[Рекурсивная функция подсчета количества элементов в списке](https://github.com/Tina-Dumilina/grokking_algorithms/blob/main/recursive_array_length.js) <br>
[Рекурсивный поиск наибольшего числа в списке](https://github.com/Tina-Dumilina/grokking_algorithms/blob/main/recursive_find_biggest_number.js)

### Быстрая сортировка массива 

1. Сначала в массиве выбирается элемент, который называется *опорным*. Например, первый элемент массива.
2. Начинаем процесс разделения: находим элементы меньше опорного и больше опорного. 
<br>Массив `[15, 10, 44, 33]` разделяется на левый подмассив - `[15, 10]`, опорный элемент - 33, правый подмассив - `[44]`. Если бы подмассивы были отсортированы, то их можно было бы объединить в порядке "левый подмассив - опорный элемент - правый подмассив". 

Быстродействие быстрой сортировки сильно зависит от выбора опорного элемента. В худшем случае это *O(n2)*, в среднем случае - *O(n * log n)*.

[Быстрый поиск](https://github.com/Tina-Dumilina/grokking_algorithms/blob/main/quick_sort.js)

## Хеш-таблицы

### Хеш-функции
Хеш-функция представляет собой функцию, которая получает строку и возвращает число. Хеш-функция неизменно связывае  строку с одним индексом.

Хеш-таблица (ассоциативный массив / словарь) = хеш-функция + массив.
Хеш-таблица использует массив для хранения данных. 

### Быстродействие
|          | Средний случай | Худший случай |
|----------|----------------|---------------|
| поиск    |      O(1)      |      O(n)     |
| Вставка  |      O(1)      |      O(n)     |
| Удаление |      O(1)      |      O(n)     |

Худший случай возникает при коллизииях. **Коллизии** – двум ключам назначается один элемент массива. 

### Поиск в ширину

### Графы
Граф моделирует набор связей. Каждый граф состоит из узлов и ребер. Узел может быть напрямую соединен с несколькими другими узлами, в таком случае они называются соседями. <br>
[Пример графа](https://python-scripts.com/wp-content/uploads/2019/11/%D0%93%D1%80%D0%B0%D1%84-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D0%94%D0%B5%D0%B9%D0%BA%D1%81%D1%82%D1%80%D1%8B.jpg)

Графы бывают:
- направленными: есть стрелки, отношения действуют в направлении стрелки (Рама -> Адит означает "Рама должен Адиту").
- ненаправленными: стрелок нет, отношение идет в обе стороны (Росс - Рейчел означает "Росс встречается с Рейчел, Рейчел встречается с Россом").

`graph = {}` <br>
`graph['you'] = ['alice', 'bob']`<br>
`graph['alice'] = ['peggy']`<br>
`graph['bob'] = []`<br>
`graph['peggy'] = []`

### Поиск в ширину
Поиск в ширину помогает ответить на вопросы двух типов:
- тип 1: существует ли путь от узла А к узлу Б?
- тип 2: как выглядит кратчаший путь от узла А к узлу Б?

[Поиск в ширину](https://github.com/Tina-Dumilina/grokking_algorithms/blob/main/breadth_first_search.js)

**Время выполнения:** *O(V+E)*, где V – количество узлов, E – количество ребер.

## Алгоритм Дейкстры
Этот алгоритм используется для поиска пути от начальной точки к конечной за кратчайшее возможное время. <br>

Алгоритм Дейкстры состоит из четырех шагов:
1. Найти узел с наименьшей стоимостью (то есть узел, до которого можно добраться за минимальное время). 
2. Обновить стоимости соседей этого узла.
3. Повторять, пока это не будет сделано для всех узлов графа.
4. Вычислить итоговый путь.

Когда вы работаете с алгоритмом Дейкстры, с каждым ребром графа связывается число, называемое **весом**. Граф с весами называется **взвешенным графом**. Использование алгоритма Дейкстры с графом, содержащим ребра с отрицательным весом невозможно, для этого существует специальный алгоритм Беллмана-Форда.

[Алгоритм Дейкстры](https://github.com/Tina-Dumilina/grokking_algorithms/blob/main/dijkstras_algorithm.js)

## Жадные алгоритмы

Жадный алгоритм на каждом шаге выбирает оптимальный вариант. Техническим языком: на каждом шаге выбирается локально-оптимальное решение, которое в итоге приводит к глобально-оптимальному решению.

(Жадный алгоритм)[https://github.com/Tina-Dumilina/grokking_algorithms/blob/main/greedy_algorithms.js]

Жадные алгоритмы применяются, когда необходимо найти приближенное решение NP-полных задач. У NP-полных задач не существует известных быстрых решений. NP-полные задачи имеют несколько характерных признаков:
- ваш алгоритм быстро работает при малом количестве элементов, но сильно замедляется при увеличении их числа,
- формулировка "все комбинации Х",
- если в задаче встречается последовательность или множество и задача не имеет простого решения.
